---
title: "Haider_preproc"
author: "Fred White"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(data.table)
library(VennDiagram)
library(gplots)
library(ggplot2)
library(GGally)
library(knitr)
library(limma)
library(reshape2)
library(RColorBrewer)
library(WGCNA)
library(DESeq2)
library(edgeR)
library(igraph)
library(scales)
library(doParallel)
library(ggfortify)
library(biomaRt)
library(GenomicRanges)
library(pheatmap)
library(tidyverse)
library(ggforce)
library(grid)
library(devtools)
library(readxl)
```


```{r}
Date <- Sys.Date()

species <- "Oryza sativa"
# ncores = 16
# registerDoParallel(cores = ncores)

baits <- c("Os11g0587000","Os04g0550600","Os01g0746400","Os01g0700900","Os06g0565100","Os01g0700500","Os08g0547900")


ref <- read.table("Rice_Annotation/Oryza_sativa.IRGSP-1.0.50.gtf", sep = "\t")      
raw_counts <- read.table("Data_Haider/raw_counts.tsv", sep = "\t", header = T)

meta <- readRDS("Data_Haider/RICE_META.rds")
```



```{r}


ref <- ref[which(ref$V3 == "transcript"),]
ref$ID <- gsub(".*gene_id ","",ref$V9)
ref$ID <- gsub(";.*","",ref$ID)

ref$transcript <- gsub(".*transcript_id ","",ref$V9)
ref$transcript <- gsub(";.*","",ref$transcript)

ref$biotype <- gsub(".*transcript_biotype ","",ref$V9)
ref$biotype <- gsub(";.*","",ref$biotype)


baits_transcript <- ref[which(ref$ID %in% baits),c(10:11)]
```


```{r}
meta <- meta[match(colnames(raw_counts[,-c(1:6)]),rownames(meta)),]
```


```{r}
#filtering low/no expression genes
counts <- raw_counts


colnames(counts)[-c(1:6)] <- meta$ID

conds <- unique(gsub("_1_.*","_",colnames(counts)[-c(1:6)]))


####filter per experimental condition on number of zeroes
i <- NULL
cond_zeroes <- data.frame(matrix())
for(i in 1:length(conds)){
  
  #print(grep(conds[i], colnames(samples)))
  
  zeroes <- rowSums(counts[,grep(conds[i], colnames(counts), fixed = T)] == 0)
  cond_zeroes <- cbind(cond_zeroes,zeroes)
  
  
}

cond_zeroes <- cond_zeroes[,-1]
colnames(cond_zeroes) <- conds


counts2 <- counts[rowSums(cond_zeroes==0) >= 4,]


cond_zeroes <- cond_zeroes[rowSums(cond_zeroes==0) >= 4,]


counts3 <- counts2[which(rowMax(data.matrix(counts2[,-c(1:6)])) < 5000),]

```



```{r}
rownames(meta) <- NULL




dds <- DESeqDataSetFromMatrix(countData = counts3[,-c(1:6)], 
                              colData = meta, 
                              design = ~ ID) 


vsd <- varianceStabilizingTransformation(object = dds, 
                                         blind = TRUE,           # do not take the design formula into account. 
                                         # best practice for sample-level QC
                                         fitType = "parametric")

# extract the matrix of variance stabilised counts
variance_stabilised_counts <- assay(vsd)

saveRDS(vsd, "Data_Haider/Rice_Counts4ASCA.RDS")
saveRDS(meta, "Data_Haider/Rice_Meta4ASCA.RDS")
```








```{r}
###DATA Preparation
#
#remove low variance and lowly expressed genes - this increases robustness of network
variance_stabilised_counts <- cbind(counts3[,1:6], variance_stabilised_counts)
counts_filt <- variance_stabilised_counts[apply(variance_stabilised_counts[,-c(1:6)], 1, var) > quantile(apply(variance_stabilised_counts[,-c(1:6)], 1, var),VARLIM),]


baits_transcript <- baits_transcript[which(baits_transcript$transcript %in% rownames(counts_filt)),]

meta_save <- meta



counts_filt <- counts_filt[,-c(1:6)]


#########
```


```{r}
##heatmap of strigolactone genes 


```


```{r}


##Co-expression network construction from filtered variance stabilised counts

#colnames(counts_filt) <- meta$sample_identifier

adj_matrix <- cor(t(counts_filt))


corclean <- function(cor_mat){
  
  ####get rid of upper triangle of correlation matrix 
  #this line is problematic for downstream analysis
  #cor_mat[upper.tri(cor_mat)] <- 999
  
  melt_adj <- melt(cor_mat)
  
  #melt_adj <- melt_adj[-which(melt_adj$value == 999),]
  melt_adj <- melt_adj[-which(melt_adj$Var1 == melt_adj$Var2),]
  
  return(melt_adj)
  
  
}



melt_adj <- corclean(adj_matrix)


rm(adj_matrix)

#madj <- melt_adj


############
#melt_adj <- melt_adj[which(melt_adj$value > CC_Cutoff),]





#take baits and return top n (user defined) coexpression candidates
#make function that takes each bait, and it's top coexpression candidates
baiter <- function(x, melt_adj){
  
  if (x %in% gsub("\\..*","",melt_adj$Var1) == F){
    print(paste0(x," doesn't pass filters"))
    CoExpCands <- data.frame(matrix(c(x,"doesn't pass filters", 0), ncol = 3))
  } else{
    
    CoExpCands <- melt_adj[which(gsub("\\..*","",melt_adj$Var1) == x),]
    CoExpCands <- CoExpCands[order(CoExpCands$value, decreasing=T),]
    
    
    #write.table(CoExpCands, paste0(x,"_Top_CoExpCands.txt"), row.names = F, quote = F)
    
    
    
  }
  rownames(CoExpCands) <- NULL
  colnames(CoExpCands) <- c("Bait","Target","PCC")
  
  return(CoExpCands)
  
}

####
####changed to madj from melt_adj below to ignore CC_Cutoff
####



baits_transcript <- baits_transcript[c(2,3,4),]


#RES contains data frame of ordered coexpression candidates for each bait
#with no CC value cutoff this is very slow
i <- NULL
RES <- list()
for(i in 1:dim(baits_transcript)[1]){
  
  RES[[i]] <- baiter(baits_transcript[i,2], melt_adj)
  print(i)
  
}

rm(melt_adj)

names(RES) <- baits_transcript[,2]





##########
#####THROW OUT RANKS FOR THE TRANSCRIPTS THAT DONT PASS FILTERS
#change thsi to make it reusable !!!!!!!!!!
RES <- RES[c(which(do.call(rbind, lapply(RES,dim))[,1] > 1))]

##make list before and name it accordingly
l <- lapply(RES, "[[",2)
l <- lapply(l, as.character)

common <- Reduce(intersect, l)


############
#####heatmaps can still be plotted with lower CCs
############

#find top 200 coexpression candidate based on rank
#very big table so need to first optimise
#find out number of coexpression candidates for each bait



com_filt <- function(res,common){
  res <- res[which(res$Target %in% common),]
  res <- cbind(res, c(1:dim(res)[1]))
  res <- res[order(res$Target),]
  colnames(res)[4] <- "Rank"
  return(res)
}







rres <- lapply(RES, com_filt, common = common)


####cbind(?) ranks together 
i <- NULL
ranked <- data.frame()
for(i in 1:length(rres)){
  
  if(i == 1){
    
    ranked <- rres[[i]][,c(2,4)]
    
  }else{
    
    ranked <- cbind(ranked,rres[[i]][,4])
    
  }
  
  
}



#change this with RES
colnames(ranked)[-1] <- baits_transcript[c(which(do.call(rbind, lapply(RES,dim))[,1] > 1)),2]

ranked$comb_rank <- rowSums(ranked[,-1])/(dim(ranked)[2] - 1)
ranked <- ranked[order(ranked$comb_rank),]





##################



###need to cleanup colnames of counts_filt

colnames(counts_filt) <- meta$ID



#######


forhm <- counts_filt[which(rownames(counts_filt) %in% ranked[1:200,1]),]
baitsforhm <- counts_filt[which(gsub("\\..*","",rownames(counts_filt)) %in% baits_transcript[,2]),]



meta$day <- factor(as.numeric(as.character(meta$day)) - 7)



anno <- cbind(meta$growth_condition, as.character(meta$day), meta$genotype)


#anno <- gsub("WT_","",meta$gc)
anno <- as.data.frame(anno)
rownames(anno) <- meta$ID

colnames(anno) <- c("growth_condition","day","genotype")
anno$day <- factor(anno$day, level = c("1","3","7","8"))

#colnames(anno) <- "Condition"


#translate labels from IDs to gene names

fornet <- rbind(baitsforhm,forhm)
labels <- rownames(fornet)


SL_genes <- read.table("~/SL_genes.txt", sep = "\t",header =T)
PSI_genes <- read.table("~/PSI_genes.txt", sep = "\t",header =T)



btg <- baits_transcript
rownames(btg) <- btg$transcript

btg$Gene <- c("MAX1-Os900","OsCCD8","OsCCD7")

rownames(btg) <- btg$transcript

labels[-which(gsub("\\..*","",labels) %in% baits_transcript[,2])] <- ""

#labels[grep(paste(labels,collapse = "|"), btg$transcript)] == btg$transcript
labels[1:3] <- btg$Gene


meta$finid <- paste0(meta$genotype, "_",meta$growth_condition, "_Day",meta$day,"_R")


meta$order <- c(1:nrow(meta))
meta <- meta[order(meta$finid),]
meta$finid <- paste0(meta$finid, c(rep(1:3,7)))

meta <- meta[order(meta$order),]

colnames(fornet) <- meta$finid


fornet <- cbind(rownames(fornet), rownames(fornet), fornet)
colnames(fornet)[1:2] <- c("transcript_id","gene_id")
fornet$gene_id <- gsub("-.*","",fornet$gene_id)
fornet$gene_id <- gsub("t","g",fornet$gene_id)



rownames(anno) <- colnames(fornet[,-c(1:2)])



heat <- pheatmap::pheatmap(data.matrix(fornet[,-c(1:2)]), 
                           #                           color = brewer.pal(name = "RdYlBu"),
                           cluster_rows = TRUE,
                           cluster_cols = TRUE, 
                           show_rownames = TRUE, 
                           show_colnames = FALSE,
                           labels_row = labels,
                           annotation_col = anno,
                           main = "Top 200 Ranked Targets + Baits",silent = T)
#pdf("2021-05-17Coexpression/hm6_3.pdf")
pdf(paste0(Date,"Coexpression_Combined/BaitsCandidates_hm.pdf"))
add.flag(heat,
         kept.labels = labels,
         repel.degree = 0.5)
#a$grobs[[6]]$gp$fontsize <- 8
#plot(a)

dev.off()


#saveRDS(fornet, "~/spectral_decomposition/RICE_CANDS.rds")
#saveRDS(meta, "~/spectral_decomposition/RICE_META.rds")



##change granscripg to transcript id 
fornet$gene_id[which(fornet$gene_id == "granscripg")] <- fornet$transcript_id[which(fornet$gene_id == "granscripg")]


#merge with ref$biotype
bionet <- merge(ref[,c(11,12)], fornet, by.x = "transcript", by.y = "transcript_id")


library(ape)

locusref <- read.gff("/zfs/omics/personal/fwhite/REFS/IRGSP-1.0_representative/locus.gff")
locusref$note <- gsub(".*Note=","",locusref$attributes)
locusref$note <- gsub("\\..*","",locusref$note)
locusref$note <- gsub(" \\(Os.*","",locusref$note)

locusref$note <- gsub("%2C",",",locusref$note)
locusref$note <- gsub("%3B",";",locusref$note)


locusref$ID <- gsub("ID=","",locusref$attributes)
locusref$ID <- gsub(";.*","",locusref$ID)


t <- locusref[which(locusref$ID %in% fornet$gene_id),]
u <- t[,c(10,11)]

v <- fornet$gene_id[-which(fornet$gene_id %in% t$ID)]
v <- cbind.data.frame(c(rep("NA",length(v))),v)

colnames(v) <- colnames(u)

w <- rbind(u,v)

bionet <- merge(w,fornet, by.x = "ID", by.y = "gene_id")

write.table(fornet, paste0(Date,"Coexpression_Combined/Baits_Candidates_Normalised_Expression.txt"), quote = F, row.names = F, sep = "\t")

write.table(fornet[heat$tree_row$order,], paste0(Date,"Coexpression_Combined/Baits_Candidates_Normalised_Expression_ORDERED.txt"), quote = F, row.names = F, sep = "\t")



write.table(bionet[heat$tree_row$order,], paste0(Date,"Coexpression_Combined/Baits_Candidates_Normalised_Expression_ORDERED_biotype_task1.txt"), quote = F, row.names = F, sep = "\t")






PCD <- prcomp(t(counts_filt), scale. = F)


#force uncertainty ellipses 
pdf(paste0(Date,"Coexpression_Combined/pcaTOMreduced_prescaled3.pdf"))
autoplot(PCD, data = meta, colour = "growth_condition", shape = "genotype", size = "day") + #, frame = T) + #, frame.type = 'norm') + too few points to calculate ellipse
  #scale_shape_manual(values=1:nlevels(as.factor(meta$compartment))) +
  #ggforce::geom_mark_ellipse(aes(color = compartment)) + #fill
  theme_bw()
dev.off()



###PCAfor just task 1 samples######################################################




#get rid of the task2 and 3 samples from counts_filt and then meta

to <- unique(c(grep("GR24", meta$growth_condition),grep("d10",meta$genotype)))

counts_filt <- counts_filt[,-to]
meta <- meta[-to,]


PCD <- prcomp(t(counts_filt), scale. = F)


#force uncertainty ellipses 
pdf(paste0(Date,"Coexpression_Combined/pcaTOMreduced_prescaled1.pdf"))
autoplot(PCD, data = meta, colour = "growth_condition", shape = "day") + #, frame = T) + #, frame.type = 'norm') + too few points to calculate ellipse
  #scale_shape_manual(values=1:nlevels(as.factor(meta$compartment))) +
  #ggforce::geom_mark_ellipse(aes(color = compartment)) + #fill
  theme_bw()
dev.off()





#########





#plot density on normal log2 data and vsd data
densityplot <- function(counts){
  
  
  mc <- melt(counts)
  colnames(mc) <- c("Gene_ID","Sample_ID","Counts")
  
  
  plot <- ggplot(mc, aes(x = Counts)) + geom_density(alpha = 0.5)+
    scale_y_continuous(labels = percent_format()) + theme_bw()+
    ggtitle("Count Distribution")
  ggsave(paste0(Date,"Coexpression/Variance_stabilised_Distribution.pdf"), plot = plot)
  
  
}

densityplot(counts_filt)







df <- PCD$rotation#[c(1,147,294,442,589,736),]
#df <- melt(df)
#colnames(df) <- c("feature","component","loading")
#df <- df[which(df$component %in% c("PC1","PC2","PC3","PC4","PC5","PC6")),]

#df$feature <- as.character(df$feature)

df <- cbind.data.frame(rownames(df), df)
colnames(df)[1] <- "metabolite"


#remove 1900 and 5100 from baits
#replot the above with the rest of the baits labelled 
baits_transcript$Gene <- c("MAX1-Os900","OsCCD8","OsCCD7")


df$colour <- df$metabolite
df$colour[-which(df$colour %in% baits_transcript$transcript)] <- "non-baits"
df$colour[which(df$colour %in% baits_transcript$transcript)] <- "baits"


pdf(paste0(Date,"Coexpression_Combined/RICE_feature_loadings_normal_PCA.pdf"))
ggplot(df, aes(x = PC1,y = PC2, colour = colour))+#, colour = metabolite)) + 
  geom_point() +
  geom_label(data = df[which(df$metabolite %in% baits_transcript$transcript),], aes(label = metabolite), nudge_y = 0.003, nudge_x = 0.001) +
  geom_point(data = df[which(df$metabolite %in% baits_transcript$transcript),]) +
  theme_bw()
dev.off()







```